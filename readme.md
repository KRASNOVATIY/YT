## Задание

Напишите на языке Python скрипт, который принимает на вход путь до файла приложения под Android и:

* выводит значение флагов безопасности в Android Manifest (WebView Metrics, usesCleartextTraffic, Backup);
* выводит список секретных кодов приложения;
* выводит список библиотек, используемых в приложении.

## Теория

#### Android Manifest

Файл из состава архивного исполняемого файла для Android (.apk).

[Manifest.xml](https://developer.android.com/guide/topics/manifest/manifest-intro) - содержит
информацию о приложении:

* задаёт имя пакета Java
* описывает компоненты (службы, операции, приёмники, поставщики)
* разрешения к API Android
* разрешения к компонентам, необходимиые для других приложений
* список связанных библиотек

#### Флаги безопасности

Флаги *Backup* и *usesCleartextTraffic* относятся к разделу
[application](https://developer.android.com/guide/topics/manifest/application-element),
а флаги *WebView Metrics*, к подразделу
[meta-data](https://developer.android.com/guide/topics/manifest/meta-data-element.html)
раздела application.

**WebView Metrics**

https://developer.android.com/guide/webapps/managing-webview

```xml
<manifest>
    <application>
    ...
    <meta-data android:name="android.webkit.WebView.MetricsOptOut"
               android:value="true" />
    </application>
</manifest>
```
value = (true|false) - WebView запрещено загружать анонимные диагностические данные в Google?
Если нет, то WebView будет отправлять в Google диагностическую информацию при дополнительном условии,
что пользователь дал своё согласие.


**usesCleartextTraffic**

https://developer.android.com/training/articles/security-config

usesCleartextTraffic = (true|false) - намеривается ли приложение использовать
открытый трафик, такой как открытый HTTP.
Если нет, компоненты платформы (HTTP, FTP, менеджер загрузок, медиаплеер)
будут запрещать запросы с использованием открытого трафика.

**Backup**

https://developer.android.com/guide/topics/data/autobackup

allowBackup = (true|false) - приложение может быть добавлено в резервную копию?
Если да, то необходимо помнить, что резервная копия может содержать личную (или чувствительную) информацию,
которая при восстановлении резервной копии или
извлечении данных из этой копии c помощью abe.jar может попасть к злоумышленникам.

#### Секретные коды приложения

Могу лишь предположить, что речь идёт о смс\телефонных кодах управления.

#### Библиотеки

Перечнь библиотек, используемых в приложении зависит от архитектуры приложения.

Приложение может быть создано с использованием инструментов:
* xamarin-NET
* native-C++
* android-java\kt
* cordova-js
* ...

Кроме того, приложение может иметь функции динамической подгрузки библиотек.
С использованием DexClassLoader.

## Практика

#### Общие мысли

Решение данной задачи представлено скриптом *apk_analyze.py*.

Скрипт использует стороннюю библиотеку *apkutils*, а именно класс *APK*.
Тактика использования объекта *APK* при реализации *APKInfo*, вместо расширения класса выбрана в связи с тем,
что данный класс, как, в прочем, и вся виблиотека, являются инструментом общего назначения.
Элементы задания же, являются более частными вопросами.
По этой же причине было применено сокрытие объекта *APK* и производной его метода *get_manifest()*

Свойство *name* выделено неслучайно, хотя для него напрямую не назначены (не переопределены) getter, setter и deleter.
Их реализация предполагается, ибо значение может быть получено различными способами и как-либо связанно с объектом
*APKInfo*.

#### Текущая реализация

- [x] Выводит значение флагов безопасности в Android Manifest
    - [x] Permissions
    - [x] WebView Metrics
    - [x] usesCleartextTraffic
    - [x] allowBackup
- [x] Выводит список секретных кодов приложения;
- [ ] Выводит список библиотек, используемых в приложении
    - [x] из структуры classes.dex
    - [x] из Manifest.xml
    - [ ] JS
    - [x] NET/Xamarin
    - [x] C/C++
- [x] Определяет факт использования динамически подгружаемых библиотек/модулей с использованием DexClassLoader

#### Запуск скрипта

1) Скрипт как исполняемый файл:
`python3 apk_analyze.py path/to/file.apk`

2) Импортирование класса и его дальнейшее использование:
```python
from apk_analyze import APKInfo

apk_info = APKInfo("path_to_apk")
# далее выделим открытые поля, не являющиеся магическими,
# отсортируем их так что свойство name будет первым,
# объекты вспомогательного класса APKOpener скроем
# выведим сначала название анализруемого пакета (поле name), а затем пары имя_метода : возвращаемое_значение
# ЗЫ: так писать не надо
for field in sorted([getattr(apk_info, m) for m in dir(apk_info) if not m.startswith("_")], key=lambda x: callable(x)):
    print(f"{field.__name__:25}: {field()}" if callable(field) else field if not isinstance(field, APKOpener) else "")
```

#### Тестирование

1) Ручное тестирование хода выполнения представлено скриптом *tests.py*.
Единственная его цель - убедиться, что скрипт не падает на избранных для тестирования файлах apk.

2) Автоматическое юнит-тестирование, представлено скриптом *unit_tests.py*.
Связывается *.gitlab-ci.yml*. Раннер локальный.

#### Улучшение

Сделал микро-веб-сервис (на основе tornado), выполняющий поставленную задачу.
Для демонстрации, запустите скрипт *app.py* и перейдите на страничку http://127.0.0.1:8888.
Это лишь заготовка сервиса (альфа-версия).